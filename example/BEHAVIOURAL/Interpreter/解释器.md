# 解释器 Interpreter
## 背景
当一个特定类型的问题发生频率足够高， 将该问题的各个实例表述为句子(例如“美利坚...”说多了就是USA)，其中的文法规则(如缩写规则)即为解释器。
另一个现实的例子就是话外音。

## 定义
>给定一个语言，定义它的**<sup>[1]</sup>文法的一种表示**，并定义一个**<sup>[2]</sup>解释器**，该解释器使用这种表示来解释语言中的句子。

## 难点 & 关键
1. 定义解释操作

    + 可以和**Visitor**将解释放入一个独立的Visitor对象
  
2. 如何构造抽象文法树
    
    + 构造抽象文法树并不是解释器模式的职责， 其可以用**表驱动的语法分析程序**或直接(客户)手动分配的方式来提供。
   
3. 对于终结符

    + 可以用**享元Flyweight**共享终结符。

> 要素
> + 抽象表达式AbstractExpression —— 声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。
> + 环境类Context —— 包含解释器之外的一些全局信息。
> + 终结符表达式TerminalExpression
>      + 实现与文法中的**终结符**相关的解释操作。
>      + 实现抽象表达式中所需的解释操作Interpret。
>      + 文法中每一个终结符都有一个具体的终结表达式与之相对应。
>      + [可选] 接受Context中的参数配置
> + 非终结符表达式NonterminalExpression
>      + 为文法中的非终结符相关的解释操作, 用来**递归**地表示中间的解释操作。
>      + [可选] 接受Context中的参数配置

## 优点
+ 可扩展性好。易于改变和拓展文法
+ 易于实现文法
+ 增加了新的解释表达式的方式。可以用Visitor来为解释程序增加新的方式。

## 不足
+ 复杂的文法难以维护  ——> 建议使用语法分析程序 或 编译器生成器 等技术。

## 适用环境
构建解释器来解决那些频繁发生的某一特定类型的问题。
+ 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；
+ 一些重复出现的问题可以用一种简单的语言来进行表达；
+ 文法较为简单时。

实现： 正则表达式




