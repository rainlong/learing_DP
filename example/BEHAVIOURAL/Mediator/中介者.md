# 中介者模式 Mediator
## 背景
随着系统中对象数量的扩大， 对象间通信变复杂。当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及很多其他对象的行为。

这里以图形面板为例，面板的各个widget往往相互约束、相互依赖。

## 定义
>用一个**<sup>[1]</sup>中介对象**来封装一系列的对象交互，使它们不需要相互了解就可以协同工作。

## 难点 & 关键
1. 中介者对象，也可以被称为“Director”

  + 负责在客户和具体组件之间的连接和组织。定义接口用于与各部件的通信。

  + 具体中介对象负责具体*协同*， 需要注册部件对象。所以**ConcreteMediator是该模式主要变化的部分**。

  + 前提： 通信的协议必须稳定且共知。这种协议是一(Mediator)对多(Colleague)的。

  + 中介者在某些情况下可以实现为“*观察者模式*”。
  
2. 部件Colleague

  + 自己的职责operation

  + 注册中介对象

  + notify —— 向中介对象请求响应/告知变化。这要求每个ConcreteColleague依据通信协议提供通信的内容。

> 要素
> + 中介者了解所有ConcreteColleague的职责和需求。
> + ConcreteMediator设计具体的协同，需要
> 
>     + <sup>[1]</sup>指定ConcreteColleague对象
>     + <sup>[2]</sup>实现收到不同请求时的交互的逻辑
>     
> + ConcreteColleague<sup>[1]</sup>实现自己的职责，<sup>[2]</sup>并了解对应的ConcreteMediator。

## 优点

+ 减少了Colleague的子类生成。将分布于多个对象间的行为集中在一起(ConcreteMeditator)，改变行为改ConcreteMediator。
+ 将具体Colleague解耦， 使Mediator和Colleague可以独立变化
+ 简化了对象协议 —— 一对多的协议
+ 对*对象如何协作*进行抽象 —— Mediator。 控制集中到了中介者中。另一方面，交互的复杂性也全部集中到了具体中介对象中。

## 不足

+ 复杂性全集中到了具体中介者中。
+ Colleague增加时，必须修改Mediator。

## 适用环境
+ 一组对象以 定义良好但复杂的方式 进行通信。产生的相互依赖关系结构混乱且难以理解。
+ 一个对象引用其他很多对象并且直接与这些对象通信，难以复用。
+ 想**定制一个分布在多个类中的行为**，但又不想生成太多的子类。