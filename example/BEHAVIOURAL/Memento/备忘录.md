# 备忘录模式 Memento
## 背景
记录一个对象的内部状态，在需要的时候能用它对对象进行恢复。要求不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态。
例如：两个水平的矩形中间有连线，现在拖动一个矩形，希望中间的连线仍能保持连接。拖动过程中时刻保持连接会造成性能上的浪费，有种策略是用鼠标松开后的位置（有点类似“帧和关键帧”的理念），这里就是用到备忘录模式。

## 定义
>备忘录可以**<sup>[1]</sup>捕获一个对象的内部状态**，并在对象之外保存该状态，在之后可以随时把对象恢复到之前保存的状态。又被成为token。

## 难点 & 关键
1. 在不破坏封装性的前提下获得一个对象的内部状态

    + 要存储的状态由发起者Orginator创建；

    + 备忘录Memento声明 friend class Orginator,持有Originator::State 。
  
2. 恢复到之前的状态

    + 发起者Originator调用Memento的相应接口。
   
> 要素
> + 备忘录Memento
>      + 声明备忘录发起者为友元类
>      + 持有状态对象
>      + 实现getState和setState
>      + 是被动的，只有创建备忘录的原发器会对它的状态进行赋值和检索
> + 原发器Originator —— 备忘录发起者
>      + 状态的来源
>      + 创建Memento对象，调用Memento对象进行恢复
>      + 也实现了getState和setState
> + [需要管理多个Token时] 备忘录负责者Caretaker
>      + 负责保存备忘录
>      + 并不对备忘录的内容进行操作或检索

## 优点
+ 发起人不负责对备忘录进行管理
+ 封装的边界，备忘录只负责保持，不对外公开，保持了封装边界。

## 不足
+ 频繁存取的代价很高，对资源的消耗很严重

## 适用环境
+ 必须在*外部*保存一个对象在某时刻的*状态*。
+ 如果提供接口让其他对象获取状态，会暴露对象的实现细节并破坏对象的封装性。





