## 行为型模式
主要从以下四个角度思考该类型的设计模式：
1. 封装变化
       =>[1] 描述 很可能会改变的方面 —— 基于类间 静态的通信关系。例如：
         Strategy、TemplateMethod - 封装算法； State - 封装状态相关的行为； 
         Mediator - 封装对象间协议； Iterator - 封装访问和遍历的方法
         Visitor - 封装对稳定数据结构的操作； Interpreter - 封装文法 ……包括其他创建型、结构型也有很多
2. 对象作为参数
       =>[2] 以参数作为对象。例如：Visitor、Command、Memento
3. 通信应该被封装还是分散(分布)
       =>[3] 通信 —— Observer、Mediator、Responsibility of Chain 
4. 对发送者和接收者的解耦
       =>[4] 发送者和接收者的解耦 - Command、Observer、Mediator
       
## 简要总结
[**观察者**](./Observer/观察者.md "查看观察者模式的说明") —— 在保持系统的一致性时，解除对象间的紧耦合。**一对多(同时)**的关系，“一”和“多”可以认为是在**不同层次**。
+ **观察者和中介者的结合使用**
+ 通过封装复杂的update语义，应用Mediator充当Subject和Subscriber的中介者
+ 应用Singleton。

[**中介者**](./Mediator/中介者.md "查看中介者模式的说明") —— 单一职责使得复杂系统中对象间的交流多边化，耦合严重。中介者建立**一对多**的关系，统筹多对象间的通信，内部实现了**对象调用的顺序逻辑**。减少**同层次类**间的耦合。
+ **观察者和中介者的结合使用**

[**策略**](./Strategy/策略.md "查看策略模式的说明") —— 使用**组合** - 因为继承将产生紧耦合
+ 具体策略对象通常是很好的细粒度对象，所以可以引入Flyweight。

[**模板**](./Template/模板.md "查看模板模式的说明") —— 用**继承**实现代码重用。
+ 调用FactoryMethod

[**命令**](./Command/命令.md "查看命令模式的说明") —— 将请求发出者和具体实现者分离。增加中间层是为了能**支持“对执行本身”的处理**，可以支持“事务”，支持取消/重做/记录操作日志等操作。
+ Composite实现宏命令。
+ Memento用来保持某个状态，用于命令的“撤销”。

[**职责链**](./ChainOfResponsibility/职责链.md "查看职责链模式的说明") —— 将请求发出者和具体实现者分离。多个对象可以处理一个请求，但需要**在运行时才能明确响应的对象**。
+ 可以和Composite一起使用，以构建的父构建作为其Successor。

[**状态**](./State/状态.md "查看状态模式的说明") —— 大量使用条件分支——对变化没有扩展性。将**不同状态封装**成子类，将决定**状态转移的逻辑**分布在各状态子类中，满足OCP。
+ 状态对象通常都是Singleton
+ 应用Flyweight共享状态对象

[**解释器**](./Interpreter/解释器.md "查看解释器模式的说明") —— 对**频繁出现的特定问题**表述为一个简单的句子(多对象的稳定组合)。
+ Composite实现抽象语法树。
+ Flyweight对应抽象语法树中的终结符。
+ Visitor提供对抽象语法树中各节点行为的可扩展性。

[**访问者**](./Visitor/访问者.md "查看访问者模式的说明") —— 针对**稳定的数据结构**(由Node/ELement组成的、稳定的数据结构)提供扩展的灵活性。但是对修改数据结构本身是十分抵触的。
+ 应用于Composite对象结构。
+ 应用与Interpreter中，用于解释。

[**备忘录**](./Memento/备忘录.md "查看备忘录模式的说明") —— 在提取对象内部属性时会破坏封装性 --> 备忘录在实现时是一个相对独立但和目标对象耦合紧密的类。保持了**封装边界**。
+ 应用于Command中，实现对命令的撤销。
+ 应用于Iterator中，捕获迭代状态。

[**迭代器**](./Iterator/迭代器.md "查看迭代器模式的说明") —— 将对容器的**访问和遍历**从容器对象中分离出来独立封装成一个对象可以独立变化。能不暴露对象内部表示，封装性良好。
+ Composite中的递归常由迭代器实现
+ 多态迭代器需要FactoryMethod来实例化适当的迭代器子类
+ Memento与迭代器一起使用(在迭代器内部持有备忘录)，用其捕获一个迭代状态。

## 对比

#### 策略 - 模板
+ 同 —— 都是为了让同一个接口可以满足OCP
+ 异 —— 策略用**组合/委托**改变**整个算法**，模板用**继承**改变**算法的一部分**。
     

MVC：应用对象(Model)+显示(View)+对输入的响应(Controller) = 观察者模式+组合模式+策略模式 —— 架构模式
