# 迭代器 Iterator
## 背景
例如：电视里的电视节目，只对节目内容感兴趣，但不想关心节目代码，希望能便利地遍历节目列表。

## 定义
>提供一种方法，顺序访问一个**<sup>[1]</sup>聚合对象**中各个元素 而又**<sup>[2]</sup>不暴露该对象的内部表示**。

## 难点 & 关键
1. 聚合对象Aggregate

  + 将“对一个聚合对象的**访问和遍历**”抽象出来，迭代器与聚合体的耦合紧密。
  
  + 聚合体提供访问容器内元素的接口， 迭代器提供抽象迭代。
  
2. 不暴露该对象的内部表示

  + 迭代器封装容器的访问接口，并实现迭代抽象(聚合体的起点、下一个等等)。

> 要素
> + 容器Container/聚合体Aggregate
>   1. 提供对元素的访问接口；
>   2. 创建迭代器 —— 容器需要持有迭代器对象,注意这里要把容器对象本身(this指针)传递给迭代器。
>     ```
>     Iterator* createIterator()
>     { return new ConcreteIntertator(this); }
>     ```
>    
> + 实现迭代器：<sup>[1]</sup>持有容器对象；<sup>[2]</sup>最基本要实现：**First、Next、IsDone和CurrentItem**四个方法(还可以有取“前一个”、“最后”等)，除此之外：
>   1. **谁控制迭代器** —— 迭代器本身(内部迭代器)、用户(外部迭代器)
>     + 内部迭代器 —— 客户提取请求，迭代器对所有元素实施该操作；
>     + 外部迭代器 —— 客户主动推进遍历过程，显式请求下一个元素。
>   2. **谁定义遍历算法** —— 聚合体本身可以定义遍历算法(**游标Cursor**)
>     + Cursor —— 仅用来表示当前位置，以此为参数执行next操作。
>     + 迭代器定义时，注意*改变甚至访问私有变量时破坏了聚合的封装性*。
>   3. **迭代器的健壮性**
>     + **保证插入和删除操作不会干扰遍历** —> 可以通过拷贝聚合来实现，但*尽量不要拷贝聚合*，因为代价太大。
>     + 可以通过*调整迭代器的内部状态*，或*在内部维护额外的信息*以保证正确的遍历。
>   4. **多态迭代器** —— 更加灵活，但有其他问题：
>     + 需要用工厂方法分配迭代器对象。
>     + 客户必须负责删除。**使用Proxy来补救** —— C++“资源分配即初始化”
>   5. **空迭代器** —— 有助于**处理边界条件**

## 优点

+ 抽象了遍历方式， 对有序容器可以使用Cursor，对hash等可以设计迭代器；

+ 可以提供多种遍历方式，例如正序、倒序；

+ 封装型良好。

## 不足

+ 要求聚合体中的元素提供统一的访问接口。(与**访问者**中的结点不同)


## 适用环境
+ 访问一个聚合对象的内容而无需暴露它的内部表示；
+ 需要对聚合对象的多种遍历；
+ 为遍历不同的聚合结构提供一个统一的接口(为了支持多态迭代)。

许多集合类库中都有迭代器的实现。

**与相关模式的配合**：
1. **组合模式Composite**: 运用到递归结构上，多使用**<sup>[1]</sup>游标Cursor**形式，树型遍历时，叶子结点返回**<sup>[2]</sup>空迭代器实例**。
2. **工厂方法Factory Method**: 多态迭代器靠FM来实例化适当的迭代器子类。
3. **备忘录Memento**: 可以用Memento捕获一个迭代的状态，迭代器内部存储Memento。

