# 观察者模式 Observer
## 背景
将一个系统分割成一系列相互协作的类有个常见的副作用：需要维护相关对象间的一致性，这往往会使得各类之间的耦合变得紧密。对于一种协作模型：即一变多变的情况，又如广播、报纸等一个对象引导多个对象变化的情况。

## 定义
>定义对象间的一种**<sup>[1]</sup>一对多**的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都**得到通知并被自动更新**。又叫“发布-订阅”的交互。

## 难点 & 关键
1. 一对多
     + 对**目标/主题 和 响应对象/观察者**之间的抽象耦合进行解耦。
     + 这种不紧密的耦合使得这种*自变对象和因变对象*中的具体操作可以独立变化，甚至可以属于系统的不同抽象层次。
2. 得到通知并被自动更新
     + 由Subject的通知接口调用每个订阅者的update。
     
> 要素
> + Subject
>      + 订阅者容器
>      + 增/减观察者 —— attach/detach
>      + 通知 —— notify() —— 遍历所有订阅者，调用Observer的响应 update()
> + ConcreteSubject
>      + 继承于主题类
>      + [可选] 持有状态 —— 引起变化的信息
>      + [可选] 提供获取状态的接口
> + Observer
>      + 定义响应接口update()
> + ConcreteObserver
>      + 继承于观察者
>      + update需要对通知的信息进行*判读*，有两种思路：一种就是条件判读，另一种就是下面的[可选]
>      + [可选] 有一个主题状态对象
>      + [可选] 在update中获取具体主题的状态，并做出响应
> + *注意上面的[可选]形式可以管理发布的信息，但是造成了耦合。*

## 优点
+ 目标和观察者间的抽象耦合不是紧密的耦合(轻度的关联关系)，易于拓展。
+ 是一种常用的触发机制， 形成一条触发链。

## 不足
+ 链式触发，在观察者较多时，效能不高。

## 适用环境
+ 当一个抽象模型有两个方面，其中一方面依赖于另一方面。将这两方面封装在独立的对象中是它们可以独立地变化和复用。
+ 一个对象引起多个对象进行响应/变化，但又不希望两方紧密耦合。

最知名的就是MVC(Model-View-Control)。





