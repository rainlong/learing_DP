## 简要总结

整体趋势是从类继承向对象复合演化，为了能创建有特定行为的对象而不至于引入许多重复代码。其中有两个核心要素：一是将关于系统使用哪些具体类的信息封装起来；二是隐藏了这里类的实例是如何创建和组合的。

[**抽象工厂**](./AbstractFactory/抽象工厂.md "查看抽象工厂的说明")
+ 可以由*FactoryMethod*实现，也可以由*Prototype*实现
+ 一个工厂通常是一个*Singleton*

[**建造者模式**](./Builder/建造者.md " 查看建造者模式的说明")
+ *Composite*通常是由Builder生成的

[**工厂方法**](./FactoryMethod/工厂方法.md "查看工厂方法模式的说明")
+ 常用于实现抽象工厂
+ 产品类通常作为模板参数使用，与Template配合使用

[**原型**](./Prototype/原型.md "查看原型模式的说明")
+ 与工厂系列的模式是竞争的，但也可以用来实现AbstractFactory。
+ 可以应用到Composite和Decorator的设计中。

[**单例**](./Singleton/单例.md "查看单例模式的说明")
+ 可以广泛地运用到许多场景中。

## 对比
#### 抽象工厂 - 建造者
+ 同 —— 都是用来创建复杂对象
+ 异 —— 抽象工厂重视多个系列的产品，内部的差异往往是用层次的，在生成对象时是立即返回的；建造者更重视*一步步*构建一个复杂对象，并在最后才返回产品。

#### 工厂方法 - 原型
+ 异 —— 工厂方法有具体工厂子类；原型不需要创建子类，但是需要针对产品类提供初始化操作，以生成不同的产品。