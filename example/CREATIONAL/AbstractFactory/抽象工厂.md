# 抽象工厂 AbstractFactory
## 背景
对于一个生产车间，一条流水线上对不同部件进行生产，当引进另一条流水线进行扩建时，就形成了同样的部件生产，两种不同的模式。

## 定义
>提供一个创建**<sup>[1]</sup>一系列相关或相互依赖对象**的接口，而无需指定它们具体的类。

## 难点 & 关键
1. 每个产品有同样的多种形式/模型，对每一种模式封装在一个工厂类中。**具体工厂类的数量与产品的模式数量一致；每个工厂类中的创建接口数与产品数一致。**

> 要素
> + 具体工厂类的数量与产品的模式数量一致
> + 每个工厂类中的创建接口数与产品数一致

## 优点
+ 易于交换产品系列。对于同一个流水线/工厂生产出来的产品，只需要对工厂实例化一次。
+ 让具体的创建实例过程与客户端分离，产品的具体类名也被具体工厂的实现分离，不会出现在客户端。

## 不足
+ 新增对象时，要对所有的工厂类进行修改。
+ 新增流水线时，继承了统一的接口，要对所有产品实现创建的接口。

## 与其他模式之间的关系
+ [1]与**工厂方法模式**一脉相承，都实现了对“开放-封闭原则”、“依赖倒置原则”的支持，不同的是，工厂方法只对工厂职责单一的情况适用；而抽象工厂更像是对生产线的封装，每个**工厂类需要维持多个产品的创建接口**，而根据不同的模式实例化不同的工厂。[2]抽象工厂中的**每个方法都是工厂方法**。在较小的系统中，[3]抽象工厂有时会**退化**为一个没有子类的简单工厂。

+ 抽象工厂一般是**单件Singleton**，以保证在系统的任何地方都可以访问。

## 拓展
+ 利用**“反射”**改进工厂方法。(简单了解，暂时没找到实例)
      
   引入**“依赖注入(Dependency Injection)”**概念，这是**IoC(Inversion of Control)**的子集概念。根本目的是**动态获取任何一个类中所有属性与方法的信息**。
   
   依赖注入的实现需要IoC容器的支持，以实现在需要的时候实现耦合(依赖)关系——即把需要的接口实现注入到需要的类中。

## 适用环境
同一个产品有不同的实现方式时。
