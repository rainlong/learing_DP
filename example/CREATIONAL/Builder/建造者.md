# 建造者 Builder
## 背景
对汽车的各个部件可以用工厂模式来生产，但对于由不同部件组合而成的汽车本身却不能使用工厂类；同样的又如：做饭是从买菜、洗菜、做菜、装盘一系列过程的综合产品。对于这种**复杂**的、**构建过程相对固定**的对象构建，我们使用建造者。

## 定义
>将一个**复杂**对象的**<sup>[1]</sup>构建与它的表示分离**，使得**<sup>[2]</sup>同样的构建**过程可以创建**<sup>[3]</sup>不同的表示**。

## 难点 & 关键
1. 复杂

  表现在需要多个组件，产品本身必须满足：<sup>[1]</sup>可以分解为多个部分，并<sup>[2]</sup>提供“添加”的接口。
  
2. 相同过程
  
  有固定的构建过程
  
3. 不同表现
  
  要将产品的构建与固定的构建过程进一步解耦，思路是在产品类的基础上，针对特定表现，实现<sup>[1]</sup>各组件的构建接口，并<sup>[2]</sup>提供产品的当前状态。
  
> 要素
> + 客户申请创建一个产品 —— 产品类 ： 
> 
>  add(COMPONENT)
> + 有对象“懂”这个产品 —— 构建类 ： 
> 
>  buildPart() 和  getProduct()
> + 按照一定的顺序构建 —— 指挥类 ： 
> 
>  public  Product  constrcut( Builder* );

## 不足
+ 针对复杂对象“精细化”构建的设计模式，在实际情景中出现的情况很少，例如对于库的设计，这种复杂对象本身是不可取的（这种库难以使用）。总的来说，从效益角度并没有太大的必要性。

反倒是下面拓展中的两种可能会被应用。

## 拓展
+ 构建者模式特性 +　“委托”实现
+ 构建者模式 - 配置文件方式实现

## 适用环境
精细化构建：复杂对象 + 固定的构建顺序