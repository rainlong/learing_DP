# 原型模式 Prototype
## 背景
一般创建实例的方法都是new，像工厂模式就是典型代表，每次需要的时候都要申请内存、初始化......对于某些需要频繁实例化而初始对象本身又变化不大的类，可以用克隆来简化实例化的过程。

## 定义
>用原型实例**<sup>[1]</sup>指定创建对象的种类**， 并通过**<sup>[2]</sup>拷贝这些原型创建**新的对象。

## 难点 & 关键
1. 指定种类

   这个模式的意图是创建一个对象，用原型来指定它的种类，拷贝只是一种手法。

2. 用拷贝来创建

   涉及**浅拷贝和深拷贝**的概念，前者复制引用，后者申请新的内存。在某些情况下，例如*原型对象中存在引用的对象*，浅拷贝无法克隆引用的内容，所以这时候要用**深拷贝**。

> 要素
> + 每个原型的子类必须实现clone操作

## 优点
+ 用克隆来创建隐藏了对象创建时的细节，同时又大大提高了效率。
+ 它可以**动态地获取对象运行时的状态**；另一方面，客户可以在运行时建立和删除原型。
+ **改变值**之后表现为新对象新行为，进一步可以注册为新原型。如高度动态的系统允许客户通过对象复合定义新行为。
+ **改变结构**以指定为新对象。
+ 减少子类的构造，原型对象自身行使“工厂”职责。

## 不足
+ 每个原型的子类都必须实现clone操作 —— 例如当内部包含一些不支持拷贝 或 循环引用的对象时，困难

## 与其他模式的关系
原型和**工厂模式**、**建造者模式**有一样的效果：*对客户隐藏了具体的产品类，因此减少了客户需要知道的名字数量，进而使客户无需改变即可使用与特定应用相关的类*。

## 适用环境
+ 当一个系统应该独立于它的产品创建、构成和表示时；**(这是针对“DIP-依赖倒置原则”来说的，对于创建新对象时与DIP冲突，无法避免要创建特化的接口时，用原型直接创建一个类型一样的类)**
  或者：
+ 当实例化的类是在*运行时*指定时，例如：**动态装载**
+ 为了避免创建一个*与产品类层次平行*的工厂类层次时；**(实际上，原型模式把对象本身当做了工厂)**
+ 当一个类的实例*只能有几个不同*状态组合中的一种时，用相应数量的原型来克隆它们会比每次手工实例化更方便些。
