# 代理模式 Proxy
## 背景
不想让接受请求的一方了解提出请求一方的信息。

## 定义
>为其他对象提供一种**<sup>[1]</sup>代理**以控制对这个对象的访问。

## 难点 & 关键
1. 代理
  + “我要做xxx”——客户提出请求，对这个请求设计**抽象主题类**；
  
  + “我知道怎么做”——由知道怎么执行请求的**具体主题类/被代理人**负责具体实现；

  + “我知道(你)想干啥，也知道你是谁”——代理Proxy类继承抽象主题类Subject，**继承请求的接口**；持有具体主题类，知道怎么实现；

  + 代理Proxy在执行被代理人想要做的事，但其他只知道Proxy，不知道被代理人。

2. 静态代理&动态代理
  + 从编码的角度，分为静态代理(上面的继承和组合，还有一种有缺陷的是重载)以及动态代理(Java提供)。后者在运行时通过**反射**动态生成代理类的对象，并确定被代理的对象，实现这一功能需要在运行时创建对象的能力。

> 要素
> + 抽象主题类 —— 提供公共接口
> + 具体主题类/被代理人 — 提供具体实现
> + 代理 —— 继承抽象主题，保持接口；持有被代理人，调用具体实现
> 
> **对于客户端来说，需要知道代理能实现的功能(即抽象主题的接口)**;创建具体实现，然后用Proxy的名号去做。

## 优点
+ 为被代理者提供访问控制，隐藏被代理者的状态信息

## 适用环境
无法或不想直接访问某个对象时，可以通过代理间接访问。主要的类型有以下几种：
+ **虚代理**： 创建开销大的对象时
+ **远程代理**： 为网上的对象创建一个局部的本地代理， 在网络状态不好时
+ **保护代理**： 对对象进行控制访问时
+ **智能指针**： 当调用真实对象时，代理处理另一些事情:计算引用计数



