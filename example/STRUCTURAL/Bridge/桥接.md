# 桥接 Bridge
## 背景
对问题按照不同原则抽象出多个维度，以满足**单一职责**和**接口的封装**。对于一个庞大的系统，客户不断递进式地提出新需求，潜在地影响设计者使用“抽象-继承”的方式。如果这些不同抽象**仅靠继承**来实现，那么在实现过程中**“父类-子类间”**这一强耦合(父变子变)的依赖关系势必限制整个系统的灵活性，并最终限制了**复用性**。

具体举例： 

    一般最自然的抽象方式是线性的、递进的。对于手机软件而言：
    手机软件-->通讯录/游戏-->M牌/N牌手机的通讯录 + M牌/N牌手机的游戏(三层继承)

由此引入**合成/聚合复用原则**，尽量使用该原则来代替类继承，以此解耦。

    手机品牌-->M牌/N牌手机
    手机软件-->通讯录/游戏
    手机软件聚合了手机品牌
    (两层继承，聚合关联)

## 定义
>**聚合**：表示一种**弱“拥有”**关系，A可以包含B，但B并不是A的一部分；

>**合成**：表示一种**强“拥有”关系**，体现了严格的部分和整体的关系。

>**桥接模式**：将**<sup>[1]</sup>抽象部分与它的实现部分分离**，使它们可以独立地变化。这里的分离的方法就是聚合。

## 难点 & 关键
1. 抽象部分与实现部分分离

  并不是让抽象类与其派生类分离，这里的*实现*指的是**抽象类和它的派生类用来实现自己的对象**。直接但不直观的说就是，抽象策略应把**可以独立变化的实现部分“抽象/分割”出来**。
  
2. 这里的**抽象**和**实现**的概念很模糊。

  **实现**是客户真正想得到的；而**抽象**是接口的限制。

> 要素
> + 警惕“不断地继承” —— 因为客户的需求往往是递进的
> + 抽象和实现相互独立
>
>  - 两者最顶层的抽象类**彼此“不认识”**，只管设计自己的职责。
>
> + **聚合**的实现
>   - *实现的具体类*只管实现自己的职责，不必认识*抽象*；
>   - *抽象的具体类*需要知道有哪些*实现*，并负责使用*实现的具体类*来完成自身的职责。
>   - 使用时，先有具体的*实现对象*，再有具体的*抽象对象*(来调动前者)

## 优点
+ 用**聚合**代替**继承**，分离了抽象接口与其实现部分，**降低了耦合性**，提供了比继承更好的解决方案。
+ 提高了系统的**可扩充性**，在两个变化维度中任意扩展一个，都不需要改变原有系统。
+ 实现细节对客户透明，可以对客户隐藏实现细节。

## 不足
+ 增加系统的理解与设计难度，由于**聚合关联建立在抽象层**，要求开发者**针对抽象进行设计**与编程。
+ 需要**正确识别出系统中独立变化的维度**，这本身有一定的局限性与难度。

## 适用环境
+ 如果一个系统需要在构件的抽象化角色和实现角色间增加更多的灵活性，避免在两个层次间建立**静态的继承联系**，该模式可以在抽象层建立**关联关系**；
+ 对于**不希望使用继承**或因为**多层次继承**导致系统中类的个数激增时；
+ 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。

