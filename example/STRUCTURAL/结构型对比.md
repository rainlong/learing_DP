关于结构型模式，主要动因在于：随着复杂系统中类和对象的规模增大，类和对象的耦合越发严重。*使用继承来解决变化进行扩充会引入耦合导致难以扩展。*

## 简要总结
[**适配器**](./Adapter/适配器.md "查看适配器模式的说明") —— 依据OCP，让接口不同的类通过适配后协同工作。关心的是解决**两个已有接口之间的不匹配问题**，为两个对象提供一定程度的间接性。不在意接口的实现与演化。

[**桥接**](./Bridge/桥接.md "查看桥接模式的说明") ——【本模式中的“抽象”不是代码实现层面的抽象】合成聚合复用原则，**找出变化并封装之**。用**组合**代替继承来实现扩展。往往应用于**设计之初**，需要对变化部分进行分析抽象，提取出具有聚合/合成关系的不同抽象层次(即该模式中提到的“抽象”与“实现”)，再用组合的方式实现对变化的需求的处理。使“抽象”和“实现”可以独立演化。
+ 可以用AbstractFactory来创建和配置一个特定的桥接模式。

[**装饰**](.//Decorator/装饰器.md "查看装饰器模式的说明") —— 以**动态、透明**的方式为单个对象**添加职责**，并在不需要时撤销相应职责。

[**组合**](./Composite/组合.md "查看组合模式的说明") —— 表示对象的**部分与整体的层次结构**，使客户可以**一致**地使用组合结构和单个对象。
+ “部件—父部件”常用于Responsibility of Chain中。
+ Decorator与Composite一起使用，继承于同一公共父类，Decorator中实现Add、Remomve和getChild的接口。
+ 可以用Flyweight组织Leaf (对于Composite：会不能使用父部件)
+ 可以用Iterator来遍历
+ 用Visitor来将分布在Composite和Leaf中的操作和行为局部化。

[**外观**](./Facade/外观.md "查看外观模式的说明") —— “**信息的隐藏**促进了软件的复用。”指的是：类之间的耦合越弱，越有利于复用。弱耦合的类被修改对相关类的影响很小。所以，若两个类/子系统不需要直接通信，就在之间引入外观对象，为子系统提供单一简单的屏障。**隔离系统不同的层次**。
+ 可以与AbstractFactory一起使用，外观提供一个统一接口，抽象工厂隐藏与平台相关的类。
+ 通常是一个Singleton。

[**享元**](./Flyweight/享元.md "查看享元模式的说明") —— 大量**重复对象**造成内存占用过多，浪费大量资源。将对象中的稳定与不稳定的属性进行抽象分离。
+ 通常和Composite结合，用*共享Leaf的有向无环图*实现逻辑上的层次结构。
+ 推荐用享元实现State和Strategy。

[**代理**](./Proxy/代理.md "查看代理模式的说明") —— **隐藏**了被代理者/原有对象的状态信息，提供访问控制。

## 对比
#### 适配器 - 代理
+ 同 —— 都是一种衔接性质的功能。
+ 异 ——
     + **目的** —— 适配器不需要虚构出代理者，直接响应特定的需求；处于对访问的保护，需要代理
     + **接口的实现** —— 适配器为适配的对象提供了一个不同接口；代理和实体具有一样的接口，仅以代理之名行事。

#### 适配器 - 桥接
+ 同 —— 都是为另一个对象提供一定的间接性。都涉及到从自身以外的一个接口向此对象转发请求。
+ 异 ——
     + 适配器**针对已有接口**，在开发**后期**。
     + 桥接需要对设计进行分析抽象，目的在于**接口部分与实现部分分离**，往往在**前期**考虑可能的变化。

#### 适配器 - 装饰器
+ 同 —— 用于为对象添加新的职责时
+ 异 ——
     + 适配器使用对象接口来实现一个全新的接口； 装饰器仅改变对象的职责而不改变对象的接口；
     + 适配器不能递归实现，装饰器可以。

#### 适配器 - 外观
+ 同 —— 都是对现存系统的封装。
+ 异 ——
     + **目的上** —— 适配器使两个已有接口(目标接口和源接口)*协同*，外观为现存系统提供*更方便的访问接口*；
     + **适用对象上** —— 适配器适配*对象*，外观适配*子系统*(粒度更大的对象)。
     + **实现上** —— 适配器直接*复用*一个原有接口，外观*定义*新的接口；
     
#### 装饰器 - 组合
+ 同 ——
     + 都可以递归组合来组织可变数目的对象。
     + 装饰器可以被视为一个**退化的、仅有一个组件的组合**，所有有类似的实现结构。
+ 异 ——
     + 装饰器的目的在于为对象添加额外的职责；组合的核心在于对象的聚合。
     + 但是仍具有**互补性**。
     
#### 外观 - 中介者
+ 同(相似) —— 抽象一些已有的类的功能，起到隔离的作用。
+ 异 —— 
     + **目的** —— 外观针对*模块的外部系统调用*，仅对子系统对象的接口进行抽象，不定义新功能。中介者针对*模块内部各子部件之间的相互调度*，对同事colleague之间的任意通信进行抽象。
     + **模式协议** —— 外观是*单向*的，中介者是*双向*的,
     + **请求的响应** —— 对外观的请求由子系统内部完成，对中介者的请求由子部件和中介者协同完成。

#### 外观 - 代理
+ 同 —— 都是出于对信息的隐藏。
+ 异 ——
     + **适用对象上** —— 外观对象代表一个子系统，代理对象代表一个单一对象；
     + **隐藏信息的方向** —— 外观模式向客户/调用者隐藏内部信息(被调用者的信息)，代理模式向目标对象隐藏客户/调用者的信息；
     + **实现上** —— 外观的客户对象理论上可以直接访问子系统的各个对象，虽然在实现时会由外观对象提供简化的调用接口，而代理不能直接访问目标对象。

#### 代理 - 装饰器
+ 同 —— 相似的实现 — 对对象提供一定程度的间接引用，
+ 异 ——
     + **目的** —— 代理为了控制对对象的访问，装饰器为对象添加新功能。
     + **实现细节上** —— 代理持有并调用具体对象；装饰器持有抽象接口，调用具体独享。