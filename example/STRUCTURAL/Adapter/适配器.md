# 适配器 Adapter
## 背景
例如：不同国籍的人交流需要翻译；同样的用电器，在国内和国外需要不同的适配器匹配电压。为了使**可控范围外**的一个**原有对象**可以满足我们的期望。

## 定义
>将某个类的接口转换成client期望的另一种接口表示。

## 难点 & 关键
通常有两种，一种是通过**继承**实现的**类适配器**，另一种是通过**组合**实现的对象适配器。

1. 类适配器 - 基于**多重继承**

 适配器类**公有继承**目标类，以保持接口一致；**私有继承**被适配类，以调用被适配类中的方法并隐藏它。
  
2. 对象适配器 - 基于**组合**
  
  仍然**公有继承**目标类；**声明（持有）一个私有对象**以获取被适配类中的方法。
  
> 要素
> + **私有**继承或**私有**声明。
> + 在接口方法(request)中调用被适配类(Adaptee)的方法。
> + 使用时，ClientTarget* apt = new Adapter();

## 优点
+ client只需要知道ClientTarget中的接口，这个接口是稳定的（被适配类是不稳定的，可变的），封闭了变化。

## 比较类适配器和对象适配器
<table style="table-layout:fixed;">
  <tr>
    <th width = "10%", bgcolor=#eeeeee></th>
    <th width = "45%", bgcolor=#eeeeee>类适配器</th>
    <th width = "45%", bgcolor=#eeeeee>对象适配器</th>
  </tr>
  
  <tr>
    <td>特点</td>
    <td>
      1.用一个具体的适配器类对源对象和客户端目标进行匹配。<br>
      2.适配器可以override(重定义/覆盖)源对象(adaptee)的部分行为>
    </td>
    <td>
      1.允许适配器与多个源对象(adaptee)(及其子类)同时工作。<br>
      2.Adapter也可以用组合的方式给所有源对象添加功能。
    </td>
  </tr>
  
  <tr>
    <td>不足</td>
    <td>
      1.因为是继承，所以需要**多重继承**的支持;<br>
      2.当想要匹配一个类以及其子类时， 类适配器不可用
    </td>
    <td>
      1.无法override(重定义/覆盖)源对象的行为<br>
      强行这么做的办法是： 先做apdatee的子类， 然后对这个子类 用类适配器来适配
    </td>
  </tr>
  
</table>
 

## 适用环境
1. 系统需要使用现有的类，但这些类的接口不符合系统的需求。
2. 想要建立一个可以**重复使用**的类，用于与一些**彼此之间关联不大的类**，包括**会在未来引进的类**一起工作。
3. 需要一个**统一的输出接口**，而**输入接口不可预知**。

总的来说可以概括为： 系统的数据和行为正确，但接口不符时

Tips: **事后控制不如事中控制，事中控制不如事前控制。**适配器模式不要乱用：

    在有小的接口不统一问题发生时，及时重构，问题不至于扩大；
    只有碰到无法改变原有设计和代码的情况时，才考虑适配。

